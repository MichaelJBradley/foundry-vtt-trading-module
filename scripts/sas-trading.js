/**
 * SasId is a unique ID for a trade good.
 * @typedef {string} SasGoodId
 */

/**
 * SasGoodName is the name of a trade good.
 * @typedef {string} SasGoodName
 */

/**
 * SasCityName is the name of a city.
 * @typedef {string} SasCityName
 */

/**
 * SasDemand is a level of the Demand enum.
 * @typedef {Symbol} SasDemand
 */

/**
 * SasScarcity is an level of the Scarcity enum.
 * @typedef {Symbol} SasScarcity
 */

/**
 * SasGood is a single trade good for one city.
 * 
 * Corresponds to the GOODS setting.
 * @typedef {Object} SasGood
 * @property {SasGoodId} id
 * @property {SasGoodName} name
 * @property {SasCityName} city
 * @property {SasDemand} demand
 * @property {SasScarcity} scarcity
 */

/**
 * SasGoods is a mapping of good IDs to trade goods.
 * @typedef {Object} SasGoods
 * @property {Object.<SasGoodId, SasGood>}
 */

/**
 * SasBaseGoods is a mapping of trade goods to their values.
 * 
 * Corresponds to the BASE_GOODS setting.
 * @typedef {Object} SasBaseGoods
 * @property {Object.<SasGoodName, number>}
 */

/**
 * SasCities is a list of city names.
 * 
 * Corresponds to the CITIES setting.
 * @typedef {Array<SasCityName>} SasCities
 */

class SasTrading {
    static ID = 'foundry-vtt-trading-module'
    static LANG = 'SAS-TRADING'
    static FLAGS = {}
    static TEMPLATES = {}
    static SETTINGS = {
        GOODS: 'goods',           // see {SasGoods}
        BASE_GOODS: 'base-goods', // see {SasBaseGood}
        CITIES: 'cities'          // see {SasCities}
    }

    /**
     * log to console prefixed with ID.
     * 
     * If force is false, it will only log if the Developer Mode module is
     * installed, and the debug flag for this module is enabled.
     * 
     * @param {boolean} force 
     * @param  {...any} args 
     */
    static log(force, ...args) {
        try {
            const debugEnabled = game.modules.get('_dev-mode')?.api?.getPackageDebugValue(this.ID)
        
            if (force || debugEnabled) {
                console.log(this.ID, '|', ...args)
            }
        } catch (e) { }
    }

    static registerSettings() {
        game.settings.register(this.ID, this.SETTINGS.GOODS, {
            scope: 'world',
            config: false,
            type: Object,
            default: {}
        })
        game.settings.register(this.ID, this.SETTINGS.BASE_GOODS, {
            scope: 'world',
            config: false,
            type: Object,
            default: {}
        })
        game.settings.register(this.ID, this.SETTINGS.CITIES, {
            scope: 'world',
            config: false,
            type: Object,
            default: []
        })
        // TODO: register a settings menu to fill stuff in
    }

    /**
     * getSettings is a helper to retrieve a setting with this module's ID.
     * @param {string} settingName 
     * @returns {*} See SETTINGS for typedefs
     */
    static getSetting(settingName) {
        return game.settings.get(this.ID, settingName)
    }

    /**
     * setSetting is a helper to store a setting with this module's ID.
     * @param {string} settingName 
     * @param {*} data See SETTINGS for typedefs
     */
    static async setSetting(settingName, data) {
        return game.settings.set(this.ID, settingName, data)
    }

    static initialize() {
        this.registerSettings()
    }
}

class SasTradingData {
    /**
     * Demand is an enum representing the different demand levels of trade goods.
     * @see {SasDemand}
     */
    static Demand = Object.freeze({
        HIGH: Symbol('high'),
        AVG: Symbol('avg'),
        LOW: Symbol('low')
    })

    /**
     * Scarcity is an enum representing the different scarcity levels of trade
     * goods.
     * @see {SasScarcity}
     */
    static Scarcity = Object.freeze({
        RARE: Symbol('rare'),
        COMMON: Symbol('common'),
        ABUNDANT: Symbol('abundant')
    })

    /**
     * goodId generates an ID for the combination of good and city.
     * @param {SasGoodName} goodName The name of the trade good
     * @param {string} city The city for the trade good
     * @returns {SasGoodId}
     */
    static goodId(goodName, city) {
        return `${goodName}#${city}`
    }

    /**
     * createGood adds a good to the DB indexed by the ID.
     * 
     * If good.id is left undefined, it will be generated by createGood.
     * If a good with this ID already exists, it does nothing.
     * @param {SasGood} good 
     */
    static async createGood(good) {
        if (!good.id) {
            good.id = this.goodId(good.name, good.city)
        }
        const goods = this.allGoods
        if (goods.hasOwnProperty(good.id)) {
            SasTrading.log(false, "good already exists:", good.id)
            // TODO: Application Warning? Error?
            return
        }

        goods[good.id] = good
        await SasTrading.setSetting(SasTrading.SETTINGS.GOODS, goods)
    }

    /**
     * updateGood updates an existing good by ID.
     * 
     * This merges the existing good with the provided good.
     * If good.id is left undefined, it will be filled in.
     * @param {SasGoodId} id 
     * @param {SasGood} good 
     */
    static async updateGood(id, good) {
        if (!good.id) {
            good.id = id
        }
        const goods = this.allGoods
        if (!goods.hasOwnProperty(id)) {
            SasTrading.log(false, "good does not exist:", id)
            // TODO: Application warning? Error?
            return
        }

        const updatedGood = foundry.utils.mergeObject(goods[id], good)
        goods[id] = updatedGood
        await SasTrading.setSetting(SasTrading.SETTINGS.GOODS, goods)
    }

    static get allGoods() {
        return SasTrading.getSetting(SasTrading.SETTINGS.GOODS)
    }
}

Hooks.once('devModeReady', ({ registerPackageDebugFlag }) => {
    registerPackageDebugFlag(SasTrading.ID)
})

Hooks.once('init', () => {
    SasTrading.initialize()
})
