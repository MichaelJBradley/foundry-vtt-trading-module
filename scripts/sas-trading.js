/**
 * SasId is a unique ID for a trade good.
 * @typedef {string} SasGoodId
 */

/**
 * SasGoodName is the name of a trade good.
 * @typedef {string} SasGoodName
 */

/**
 * SasCityName is the name of a city.
 * @typedef {string} SasCityName
 */

/**
 * SasDemand is a level of the Demand enum.
 * @typedef {Symbol} SasDemand
 */

/**
 * SasScarcity is an level of the Scarcity enum.
 * @typedef {Symbol} SasScarcity
 */

/**
 * SasGood is a single trade good for one city.
 * 
 * Corresponds to the GOODS setting.
 * @typedef {Object} SasGood
 * @property {SasGoodId} id
 * @property {SasGoodName} name
 * @property {SasCityName} city
 * @property {SasDemand} demand
 * @property {SasScarcity} scarcity
 */

/**
 * SasGoods is a mapping of good IDs to trade goods.
 * @typedef {{SasGoodId: SasGood}} SasGoods
 */

/**
 * SasBaseGoods is a mapping of trade goods to their values.
 * 
 * Corresponds to the BASE_GOODS setting.
 * @typedef {{SasGoodName: number}} SasBaseGoods
 */

/**
 * SasCities is a list of city names.
 * 
 * Corresponds to the CITIES setting.
 * @typedef {Array<SasCityName>} SasCities
 */

class SasTrading {
    static ID = 'foundry-vtt-trading-module'
    static LANG = 'SAS-TRADING'
    static FLAGS = {}
    static TEMPLATES = {}
    static SETTINGS = {
        GOODS: 'goods',           // see {SasGoods}
        BASE_GOODS: 'base-goods', // see {SasBaseGood}
        CITIES: 'cities'          // see {SasCities}
    }

    /**
     * log to console prefixed with ID.
     * 
     * If force is false, it will only log if the Developer Mode module is
     * installed, and the debug flag for this module is enabled.
     * 
     * @param {boolean} force 
     * @param  {...any} args 
     */
    static log(force, ...args) {
        try {
            const debugEnabled = game.modules.get('_dev-mode')?.api?.getPackageDebugValue(this.ID)
        
            if (force || debugEnabled) {
                console.log(this.ID, '|', ...args)
            }
        } catch (e) { }
    }

    static registerSettings() {
        game.settings.register(this.ID, this.SETTINGS.GOODS, {
            scope: 'world',
            config: false,
            type: Object,
            default: {}
        })
        game.settings.register(this.ID, this.SETTINGS.BASE_GOODS, {
            scope: 'world',
            config: false,
            type: Object,
            default: {}
        })
        game.settings.register(this.ID, this.SETTINGS.CITIES, {
            scope: 'world',
            config: false,
            type: Object,
            default: []
        })
        // TODO: register a settings menu to fill stuff in
    }

    /**
     * getSettings is a helper to retrieve a setting with this module's ID.
     * @param {string} settingName 
     * @returns {(SasGoods|SasBaseGoods|SasCities)} See SETTINGS for more info.
     */
    static getSetting(settingName) {
        return game.settings.get(this.ID, settingName)
    }

    /**
     * setSetting is a helper to store a setting with this module's ID.
     * @param {string} settingName 
     * @param {(SasGoods|SasBaseGoods|SasCities)} data See SETTINGS for typedefs
     */
    static async setSetting(settingName, data) {
        return game.settings.set(this.ID, settingName, data)
    }

    static initialize() {
        this.registerSettings()
    }
}

class SasTradingGoodData {
    /**
     * Demand is an enum representing the different demand levels of trade goods.
     * @see {SasDemand}
     */
    static Demand = Object.freeze({
        HIGH: Symbol('high'),
        AVG: Symbol('avg'),
        LOW: Symbol('low')
    })

    /**
     * Scarcity is an enum representing the different scarcity levels of trade
     * goods.
     * @see {SasScarcity}
     */
    static Scarcity = Object.freeze({
        RARE: Symbol('rare'),
        COMMON: Symbol('common'),
        ABUNDANT: Symbol('abundant')
    })

    /**
     * goodId generates an ID for the combination of good and city.
     * @param {SasGoodName} goodName The name of the trade good
     * @param {string} city The city for the trade good
     * @returns {SasGoodId}
     */
    static goodId(goodName, city) {
        return `${goodName}#${city}`
    }

    /**
     * createGood adds a good to the DB indexed by the ID.
     * 
     * If good.id is left undefined, it will be generated by createGood.
     * If a good with this ID already exists, it does nothing.
     * The bare minimum to define a new good is name and city.
     * @param {SasGood} good 
     */
    static createGood(good) {
        if (!good.name || !good.city) {
            SasTrading.log(false, "good must have at least name and city properties", good)
            return
        }
        if (!good.id) {
            good.id = this.goodId(good.name, good.city)
        } else if (good.id !== this.goodId(good.name, good.city)) {
            SasTrading.log(false, "good.id '", good.id, "' does not match expected id:", this.goodId(good.name, good.city))
            return
        }

        const goods = this.allGoods
        if (goods.hasOwnProperty(good.id)) {
            SasTrading.log(false, "good already exists:", good.id)
            // TODO: Application Warning? Error?
            return
        }

        goods[good.id] = good
        return SasTrading.setSetting(SasTrading.SETTINGS.GOODS, goods)
    }

    /**
     * updateGood updates an existing good by ID.
     * 
     * This merges the existing good with the provided good.
     * If good.id is provided, it must match the provided ID and be the
     * resulting ID for the name and city.
     * @param {SasGoodId} id 
     * @param {SasGood} good 
     */
    static updateGood(id, good) {
        // Validate the provided good.id is correct
        if (good.id && good.id !== id) {
            SasTrading.log(false, "good.id does not match id:", id, good)
            return
        }
        // If good name and city are provided, they must result in the same ID
        if ((good.name && good.city) && id !== this.goodId(good.name, good.city)) {
            SasTrading.log(false, "provided good name and city do not match id:", id, good)
            return
        }
        const goods = this.allGoods
        if (!goods.hasOwnProperty(id)) {
            SasTrading.log(false, "good does not exist:", id)
            // TODO: Application warning? Error?
            return
        }
        // Name and city can never change
        if (good.name && good.name !== goods[id].name) {
            SasTrading.log(false, "cannot change name:", "provided:", good, "existing:", goods[id])
            return
        }
        if (good.city && good.city !== goods[id].city) {
            SasTrading.log(false, "cannot change city:", "provided:", good, "existing:", goods[id])
            return
        }

        const updatedGood = foundry.utils.mergeObject(goods[id], good)
        goods[id] = updatedGood
        return SasTrading.setSetting(SasTrading.SETTINGS.GOODS, goods)
    }

    /**
     * deleteGood deletes a good by ID
     * @param {SasGoodId} id
     */
    static deleteGood(id) {
        const goods = this.allGoods
        if (!goods.hasOwnProperty(id)) {
            SasTrading.log(false, "good does not exist:", id)
            // TODO: Application warning? Error?
            return
        }
        const updatedGoods = foundry.utils.mergeObject(goods, {[`-=${id}`]: null}, {performDeletions: true})
        return SasTrading.setSetting(SasTrading.SETTINGS.GOODS, updatedGoods)
    }

    /**
     * Get all goods mapped by id.
     * @returns {SasGoods}
     */
    static get allGoods() {
        return SasTrading.getSetting(SasTrading.SETTINGS.GOODS)
    }

    /**
     * Get all goods mapped by city.
     * @returns {{SasCityName: {SasGoodName: SasGood}}}
     */
    static get goodsByCity() {
        const goods = this.allGoods
        const cityGoods = {}
        Object.entries(goods).forEach(([_, good]) => {
            const city = good.city
            if (!cityGoods.hasOwnProperty(city)) {
                cityGoods[city] = {}
            }
            cityGoods[city][good.name] = good
        })
        return cityGoods
    }

    /**
     * Get all goods mapped by name.
     * @returns {{SasGoodName: {SasCityName: SasGood}}}
     */
    static get goodsByName() {
        const goods = this.allGoods
        const namedGoods = {}
        Object.entries(goods).forEach(([_, good]) => {
            const name = good.name
            if (!namedGoods.hasOwnProperty(name)) {
                namedGoods[name] = {}
            }
            namedGoods[name][good.city] = good
        })
        return namedGoods
    }

    /**
     * getGood is a convenience function to get a good by ID.
     * @param {SasGoodId} id 
     * @returns {SasGood}
     */
    static getGood(id) {
        const goods = this.allGoods
        if (!goods.hasOwnProperty(id)) {
            SasTrading.log(false, "good with does not exist with id:", id)
            return
        }
        return goods[id]
    }
}

class SasTradingBaseGoodData {

    /**
     * createBaseGood adds a new trade good with its base value.
     * @param {SasGoodName} goodName 
     * @param {number} baseValue 
     */
    static createBaseGood(goodName, baseValue) {
        const baseGoods = this.allBaseGoods
        if (baseGoods.hasOwnProperty(goodName)) {
            SasTrading.log(false, "base good already exists:", goodName)
            return
        }

        baseGoods[goodName] = baseValue
        return SasTrading.setSetting(SasTrading.SETTINGS.BASE_GOODS, baseGoods)
    }

    /**
     * updateBaseGood updates the base value of a trade good.
     * @param {SasGoodName} goodName 
     * @param {number} baseValue 
     */
    static updateBaseGood(goodName, baseValue) {
        const baseGoods = this.allBaseGoods
        if (!baseGoods.hasOwnProperty(goodName)) {
            SasTrading.log(false, "base good does not exist with name:", goodName)
            return
        }

        baseGoods[goodName] = baseValue
        return SasTrading.setSetting(SasTrading.SETTINGS.BASE_GOODS, baseGoods)
    }

    /**
     * deleteBaseGood deletes a trade good from the base value list.
     * @param {SasGoodName} goodName 
     * @returns 
     */
    static deleteBaseGood(goodName) {
        const baseGoods = this.allBaseGoods
        if (!baseGoods.hasOwnProperty(goodName)) {
            SasTrading.log(false, "base good does not exist with name:", goodName)
            return
        }

        const updatedBaseGoods = foundry.utils.mergeObject(baseGoods, {[`-=${goodName}`]: null}, {performDeletions: true})
        return SasTrading.setSetting(SasTrading.SETTINGS.BASE_GOODS, updatedBaseGoods)
    }

    /**
     * getBaseGood gets the base value of a trade good.
     * @param {SasGoodName} goodName 
     * @returns {number}
     */
    static getBaseGood(goodName) {
        const baseGoods = this.allBaseGoods
        if (!baseGoods.hasOwnProperty(goodName)) {
            SasTrading.log(false, "base good does not exist with name:", goodName)
            return
        }
        return baseGoods[goodName]
    }

    static get allBaseGoods() {
        return SasTrading.getSetting(SasTrading.SETTINGS.BASE_GOODS)
    }
}

Hooks.once('devModeReady', ({ registerPackageDebugFlag }) => {
    registerPackageDebugFlag(SasTrading.ID)
})

Hooks.once('init', () => {
    SasTrading.initialize()
})
